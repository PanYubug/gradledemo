Map：双列集合，一次存一堆，键值对。要保证键的唯一性

1、添加
    v put(key,value); 返回value的前一个值
    putAll(Map<k,v> map);
2、删除
    void clear();
    v remove(keu);
3、判断
    boolean containsKey(object);
    boolean containsValue(object);
    boolean isEmpty();

4、获取
    v get(key);
    int size();


Map
    Hashtable:  哈希表，是同步的。不允许null键，null值
    HashMap:    哈希表，是不同步，不允许null键，null值
    TreeMap:    二叉树，不同步，可以对map集合中的键排序







泛型：
    在jdk1.4版本之前，容器什么类型对象都可以存储，但是在取出时，需要用到对象特有内容，需要向下转型。
    但是对象的类型不一致，导致了向下转型发生了ClassCastException异常。
    为了避免这个问题，只能主观上控制，往集合中存储的对象类型保持一致。

    JDK1.5以后，解决了该问题，在定义集合时，就直接明确集合中存储元素的具体类型。
    这样，编译器在编译时，就可以对集合中存储的对象类型进行检查。
    一旦发现类型不匹配，就编译失败。这个技术就是泛型技术。


好处：
    1、将运行时期的问题转移到了编译时期，可以更好的让程序员发现问题并解决问题。
    2、避免了向下转型的麻烦。

总结：泛型就是应用在编译时期的一项安全机制


泛型的擦除：编译器通过泛型对元素类型进行检查，只要检查通过，就会生成class文件，但在class文件中，就将泛型标识去掉

泛型的表现：泛型技术在集合框架找那个应用的范围很大
          什么时候需要写泛型呢？1、只要看到类，或者接口在描述时，右边定义有<>，就需要泛型。
          其实是，容器在不明确操作元素的类型的情况下，对外提供了一个参数<>。
          使用容器时，只要将具体的类型实参传递给参数即可。
          说白了，泛型就是，传递类型参数。



集合框架的工具类
Collections：定义的都是操作collection的静态方法
    1、对list排序
    2、sort(list)

    














